
\documentclass[notitlepage]{report}
\usepackage{amssymb}
\usepackage[margin=1in]{geometry}
\usepackage{enumerate}
\usepackage{booktabs}

\title{\vspace{-0.5in}Virtual Machines and Managed Runtimes \\ Assignment 3 Answers}
\date{\vspace{-0.5in}September 25, 2015}
\author{\vspace{-0.5in}Liang Gong and Ben Mehne\vspace{-0.5in}}

\begin{document}
\maketitle

\begin{table}[!htp]
\centering
\caption{Runtime Statistics}
\label{statistics}
{\footnotesize
\begin{tabular}{lllllll}
\toprule
test case & total time (ms)    & entry lookup (ms) & \# calls & \# int calls & \# array calls & \# env calls \\
\midrule
bsearch        & 0.106          & 0.000          & 190            & 145            & 45             & 0              \\
inheritance    & 0.054          & 0.000          & 6              & 2              & 0              & 4              \\
cplx           & 0.090          & 0.002          & 43             & 33             & 0              & 10             \\
lists          & 0.156          & 0.012          & 135            & 40             & 0              & 95             \\
vector         & 0.122          & 0.007          & 130            & 72             & 42             & 16             \\
fibonacci      & 0.180          & 0.000          & 611            & 611            & 0              & 0              \\
sudoku         & 332.488        & 8.751          & 1586161        & 1046536        & 450449         & 89176          \\
sudoku2        & 65916.306      & 1761.578       & 316868201      & 209055201      & 90034000       & 17779000       \\
hanoi\_BM      & 0.245          & 0.000          & 463            & 463            & 0              & 0              \\
stacks\_BM     & 0.110          & 0.007          & 132            & 72             & 30             & 30             \\
morehanoi\_BM  & 0.782          & 0.095          & 1681           & 852            & 251            & 578            \\
\bottomrule
\end{tabular}
}
\end{table}

\begin{enumerate}
	\item
			See Table~\ref{statistics}.  Ben Mehne's implementation of hanoi, stacks, and morehanoi is the submitted and tested version.
	\item The verifier could verify the following properties:
		\begin{enumerate}
			\item Return instructions run when the operand stack only has one item on it.
			\item The goto instruction only branches to areas within a function call (and they branch backwards)
			\item Call and call slot instructions are only done when there are n (n+1 for call slot instructions) or more items on the stack
			\item All instructions that pop from the stack only do so when the stack is guaranteed to be non-empty (this includes set slot, get slot, drop, set global, set local, print instruction n's arguments, and array instruction).  These last two verification types would be done with stack height analysis (an abstract interpretation).
		\end{enumerate}
	\item The interpreter spends less time in environment-entry lookup because global variables and functions (due to quickening) are no longer looked up via string key.  Object variables and methods are looked by string key though.
	\item Break, continue, and goto statements are easily supported via the goto instruction.  Break would have goto go to the end of the loop, continue to the predicate for the loop, and goto would be nearly identical to the instruction itself.  The return instruction can be used for a return statement (using even more-minor changes than the goto instruction to use it for the goto statement).
	\item The AST interpreter requires significant changes to implement returning from the middle of an expression (the body of a function, which is a logical expression) because the AST interpreter assumes that control flow mimics Feeny lexical/grammatical structure.  By adding a return expression to the language, we are creating a single expression that does not follow the control flow implied by the parse tree of the language.  We would work around this issue with exceptions or set/longjmp, a means of arbitrarily unwinding the expression-evaluation stack.  In the bytecode interpreter, on the other hand, the control flow is intended to be direct from one instruction to another (either by increment of the virtual PC or by setting it) as opposed to nested evaluation of an expression.  Because a return instruction is direct in the sense that you are only jumping back to one location, it is simple to implement.

		In short, the AST interpreter follows the nesting depths of the language via the call stack, while the bytecode interpreter works with unrolled expressions and by reading a bytecode and executing it without using the call stack to direct execution.  This means that returning is as simple from a nested expression as it is from the end of an function's body for the bytecode interpreter.
\end{enumerate}

\end{document}
